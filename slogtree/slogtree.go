// Package slogtree provides logging services built on top of slog, Go's
// structured logging package. There are two significant design aspects
// which differentiate slogtree from just using slog directly, and from other
// log packages:
//
//   - slogtree is designed to be reasonable for usage not just for program
//     authors but also for library authors. This is because slogtree tries
//     to act as a [neutral nexus] to connect log message producers to
//     log message consumers configured by the program as a whole.
//     By using slogtree, library writers can provide log output while
//     ensuring that the program as a whole can always control
//     how that log output is handled and dispatched.
//
//   - slogtree strongly encourages library writers to define "known log message types".
//     This is essentially a type system for log messages. The slog "message"
//     field is always set to a message type string, which is a defined type value
//     like "REQUEST_FAILED" rather than a freeform phrase.
//
//     This approach provides some interesting advantages. For example, you can
//     attach documentation to every message type you define, and automatically
//     get an export of all supported message types and associated documentation.
//
// [neutral nexus]: https://www.devever.net/~hl/nexuses
package slogtree

import (
	"context"
	"golang.org/x/exp/slog"
	"runtime"
	"time"
)

// Represents a known log message type. Belongs to exactly one Facility.
type Known struct {
	msgType string
	level   slog.Level
	logger  *Logger
	meta    map[string]any
}

// Returns the message type identifier of the known log message type.
func (k *Known) Name() string {
	return k.msgType
}

// Returns the facility which the known log message type belongs to.
func (k *Known) Facility() Facility {
	return facilityWrapper{k.logger}
}

// Returns the level used for this known log message type.
func (k *Known) Level() slog.Level {
	return k.level
}

// Returns the metadata item with the given name on the known, or nil
// if it is not set.
func (k *Known) Metadata(name string) any {
	v, _ := k.meta[name]
	return v
}

// Visit all metadata items registered on the known log message type.
// Short-circuits if visitFunc returns false.
func (k *Known) VisitMetadata(visitFunc func(name string, value any) bool) {
	for k, v := range k.meta {
		if !visitFunc(k, v) {
			return
		}
	}
}

// Log facilities are intended to form a hierarchy up to a single root log
// facility per peogram. In particular, they are intended to reflect the
// *static* structure of a program's decomposition into self-contained units of
// code (i.e., packages).
//
// They are not intended to be created dynamically, and it is expected that all
// log facilities are created at startup (as package-levell variables or in a
// func init()) and exist for the duration of the program.
//
// This interface provides the external control interface for a facility, which
// is intended to be used by code outside of a package declaring a given
// facility in order to manipulate it. For the methods intended to be used by
// code inside a given package to log using a facility, see Logger.
type Facility interface {
	// The log facility name. The recommended method of naming log sites is using
	// a dotted notation such as "foo.bar.baz", where "foo" is the most major
	// denomination and "baz" is the most minor denomination.
	Name() string

	// Returns the parent site, or nil if this is the root site.
	Parent() Facility

	// Visits all child facilities declared directly under this site.
	// Short-circuits if visitFunc returns false. Do not attempt to create new
	// facilities during a call to this function. It is acceptable to call
	// VisitChildren on a child facility while inside VisitChildren.
	VisitChildren(visitFunc func(f Facility) bool)

	// Calls visitFunc for every known log message type registered directly under
	// this facility. Short-circuits if visitFunc returns false.
	VisitKnowns(visitFunc func(k *Known) bool)

	// Returns the currently configured handler on this log site. Note that this
	// does not reflect inheritance (i.e., if you call SetHandler(nil), this will
	// return nil, even if the parent has a handler set when logging occurs on
	// this facility).
	Handler() slog.Handler

	// Sets the slog.Handler used to handle messages generated by this facility.
	// If a handler is not set on this Facility, the handler of the parent facility
	// is used instead, and so on. If no handler is set on the root facility,
	// slog.Default() is used.
	SetHandler(h slog.Handler)
}

// The root facility. All facilities form part of a tree which is ultimately
// rooted in the Root facillity. This has a name of "", and it is the only
// Facility for which calling Parent on it returns nil.
func Root() Facility {
	return rootFacility
}

var rootLogger = &Logger{}
var rootFacility Facility = facilityWrapper{rootLogger}

// Logger is the 'internal' side of a Facility. Calls to the methods of Logger
// are used to log messages using the associated facility.
type Logger struct {
	name     string
	parent   *Logger
	children []*Logger
	knowns   []*Known
	handler  slog.Handler
	logger   *slog.Logger
}

// Creates a new log facility.
//
// The Facility interface returned by this structure is intended to allow applications
// consuming a library to configure how that library logs to the world; thus when a library
// instantiates a Facility, it should export the Facility interface.
// Conversely, the Logger structure is intended for internal usage by that library
// to actually perform logging and should not be exported. The idiomatic usage is:
//
//	var log, Log = slogtree.NewFacility("foo/bar")
//
// Creating a site with a name `x` where there already exists one or more sites
// with names `x/y` (where `y` is an arbitrary suffix) automatically makes
// those sites children of the site being created. Conversely, if a site `x/y`
// (where `y` is an arbitrary suffix) is created after a site with name `x` is
// created, it will automatically become a child of site `x`. In other words,
// the hierarchical site names automatically imply and generate parent-child
// relations regardless of whether parent or child site is created first.
//
// The motivation behind this scheme is that it avoids circular dependencies
// between packages and allows a library package declaring a site `x/y` to be
// imported and initialised prior to a depending package declaring a site `x`
// being initialised.
func NewFacility(name string, args ...any) (*Logger, Facility) {
	l := &Logger{
		name:   name,
		parent: rootLogger,
	}
	return l, facilityWrapper{l}
}

type facilityWrapper struct {
	l *Logger
}

func (fw facilityWrapper) Name() string {
	return fw.l.name
}

func (fw facilityWrapper) Parent() Facility {
	return facilityWrapper{fw.l.parent}
}

func (fw facilityWrapper) VisitKnowns(visitFunc func(k *Known) bool) {
	for _, k := range fw.l.knowns {
		if !visitFunc(k) {
			return
		}
	}
}

func (fw facilityWrapper) VisitChildren(visitFunc func(c Facility) bool) {
	for _, c := range fw.l.children {
		if !visitFunc(facilityWrapper{c}) {
			return
		}
	}
}

func (fw facilityWrapper) Handler() slog.Handler {
	return fw.l.handler
}

func (fw facilityWrapper) SetHandler(h slog.Handler) {
	fw.l.handler = h
	fw.l.logger = slog.New(h)
}

// Make a known log message type which has a severity level of Debug.
//
// This is equivalent to calling MakeKnown with a level of slog.LevelDebug.
func (l *Logger) MakeKnownDebug(msgType string, args ...any) *Known {
	return l.MakeKnown(slog.LevelDebug, msgType, args...)
}

// Make a known log message type which has a severity level of Info.
//
// This is equivalent to calling MakeKnown with a level of slog.LevelInfo.
func (l *Logger) MakeKnownInfo(msgType string, args ...any) *Known {
	return l.MakeKnown(slog.LevelInfo, msgType, args...)
}

// Make a known log message type which has a severity level of Warn.
//
// This is equivalent to calling MakeKnown with a level of slog.LevelWarn.
func (l *Logger) MakeKnownWarn(msgType string, args ...any) *Known {
	return l.MakeKnown(slog.LevelWarn, msgType, args...)
}

// Make a known log message type which has a severity level of Error.
//
// This is equivalent to calling MakeKnown with a level of slog.LevelError.
func (l *Logger) MakeKnownError(msgType string, args ...any) *Known {
	return l.MakeKnown(slog.LevelError, msgType, args...)
}

// Make a known log message. msgType should be a message type identifier which
// is unique within the log facility scope, not a human readable message or
// ad-hoc phrase. Returns a Known, which represents the given log message type.
// This object should be used to log messages of that type.
//
// The arguments are intepreted similarly to the arguments of a slog log function;
// i.e., the first argument is an attribute name, the second argument is the
// attribute value, and so on.
//
// Note that attributes on a known log message type are NOT copied
// automatically into log messages logged using that known log message type.
// The reason for this is that such attributes are static with regard to a
// particular log message type, therefore they provide no useful additional
// information which is specific to the log message and would only make logs
// take up more space unnecessarily. Rather, these metadata attributes on known
// message types can be walked and reflected automatically and used to produce
// more useful information from a log message given its type, or to export
// information about log message types from a program automatically.
func (l *Logger) MakeKnown(level slog.Level, msgType string, args ...any) *Known {
	k := &Known{
		level:   level,
		msgType: msgType,
		logger:  l,
	}
	if len(args) > 0 {
		k.meta = map[string]any{}
		isKey := true
		var key string
		if len(args)%2 != 0 {
			panic("MakeKnown metadata must be an even number of arguments")
		}
		for _, arg := range args {
			if isKey {
				var ok bool
				key, ok = arg.(string)
				if !ok {
					panic("MakeKnown metadata key must be a string")
				}
			} else {
				k.meta[key] = arg
			}
			isKey = !isKey
		}
	}
	l.knowns = append(l.knowns, k)
	return k
}

func (l *Logger) getLogger() *slog.Logger {
	if l.logger != nil {
		return l.logger
	}
	if l.parent == nil {
		return nil
	}
	return l.parent.getLogger()
}

// For advanced usage; this is like LogCtx but allows you to specify how many
// call frames we should traverse up to determine the calling source code
// filename and line number. This is only needed if you want to build your own
// logging infrastructure on top of a Logger.
func (l *Logger) LogCtxStack(ctx context.Context, depth int, k *Known, args ...any) {
	if log := l.getLogger(); log != nil {
		var pcs [1]uintptr
		runtime.Callers(depth, pcs[:])
		r := slog.NewRecord(time.Now(), k.level, k.msgType, pcs[0])
		r.Add(args...)
		log.Handler().Handle(ctx, r)
	}
}

// Log using a context and a known log message type.
func (l *Logger) LogCtx(ctx context.Context, k *Known, args ...any) {
	l.LogCtxStack(ctx, 3, k, args...)
}

// For advanced usage; see LogCtxStack. Corresponds to LogAttrs.
func (l *Logger) LogAttrsStack(ctx context.Context, depth int, k *Known, attrs ...slog.Attr) {
	if log := l.getLogger(); log != nil {
		var pcs [1]uintptr
		runtime.Callers(depth, pcs[:])
		r := slog.NewRecord(time.Now(), k.level, k.msgType, pcs[0])
		r.AddAttrs(attrs...)
		log.Handler().Handle(ctx, r)
		//log.LogAttrs(ctx, k.level, k.msgType, attrs...)
	}
}

// Log using a context and a known log message type.
func (l *Logger) LogAttrs(ctx context.Context, k *Known, attrs ...slog.Attr) {
	l.LogAttrsStack(ctx, 3, k, attrs...)
}
